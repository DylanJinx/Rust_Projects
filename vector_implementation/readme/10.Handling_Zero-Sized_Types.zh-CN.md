# 1. 处理零大小类型

处理零大小类型（Zero-Sized Types, ZST）在 Rust 中是一个特别的话题，因为它们在内存管理和类型安全方面提出了一些独特的挑战。零大小类型，如你所述，不占用任何内存空间，这在处理原始分配和指针操作时需要特别注意。下面是一些详细的解释：

## 1.1 原始分配器的行为

当你尝试为零大小类型分配内存时，即使传入的大小为 0，原始分配器（如 Rust 的 `alloc` 库）可能会有未定义的行为。通常，分配器要求为每个分配请求返回一个有效的非空指针，即使请求的大小为零。这可能导致分配器返回一个特殊的、非空但不指向任何实际内存的指针。

## 1.2 原始指针的偏移

对于零大小类型来说，原始指针的偏移操作（`ptr::offset`）通常是无效的（no-ops），因为不需要移动指针来访问连续的元素（实际上并没有元素）。这对于需要通过指针迭代器进行迭代的数据结构（如在 C 风格代码中常见）是个问题，因为指针的增加操作本质上没有任何作用。

## 1.3 非空悬挂指针（NonNull::dangling）

由于 ZST 不占用内存，对它们的"分配"可以通过使用 `NonNull::dangling()` 来处理。这个函数返回一个满足非空要求但实际上不指向任何有效内存的指针。这种方式很方便，因为它提供了一个有效的指针值，但不涉及任何内存分配。

## 1.4 处理 ZST 的操作

对于 ZST 的操作，如 `ptr::read` 和 `ptr::write`，实际上并不进行任何内存访问操作，因为没有实际的数据需要读取或写入。因此，这些操作可以视为 no-op（无操作），在使用时不需要改变指针。

## 1.5 防止容量溢出

虽然 ZST 不需要内存分配，但在处理这些类型的容器（如 `Vec<T>`）时，仍然需要管理元素数量。特别是，容器通常需要防止整数溢出，这在增加或删除元素时可能发生。对于 ZST，这意味着必须有额外的检查来确保计数不会超过 `usize::MAX`，从而防止潜在的安全问题。

# 2. 修改`RawVec`使其支持 ZST

## 2.1 `new()`

```rust
impl<T> RawVec<T> {
    pub fn new() -> Self {
        // 暂时不支持 ZST：Zero Sized Type
        // assert!(mem::size_of::<T>() != 0, "TODO: implement ZST support");

        // 支持 ZST
        let cap = if mem::size_of::<T>() == 0 { usize::MAX } else { 0 };

        RawVec {
            ptr: NonNull::dangling(),
            cap: cap,
        }
    }
}
```

在 `RawVec<T>` 实现中，为零大小类型 (ZST) 设置 `cap` 为 `usize::MAX` 是一种处理 ZST 内存管理的策略。这种设计选择有几个理由：

1. **零大小的类型不占用内存**：由于 ZST 实际上不占用任何内存（它们的大小为零），在逻辑上你可以认为可以存储无限多的 ZST 实例。这是因为，不论你“分配”多少个 ZST 实例，实际上都不会使用任何额外的内存。因此，设置 `cap` 为 `usize::MAX` 是一种表示这种“无限容量”概念的方法。

2. **避免不必要的内存操作**：在 Rust 中，处理内存通常涉及大小和容量的计算。对于非零大小的类型，增加或减少容量意味着实际的内存分配或释放。然而，对于 ZST，这些操作是没有必要的，因为实际上并不涉及内存的物理分配。通过将容量设置为最大值，可以简化内部逻辑，对于所有基于容量的操作（如 `push`、`pop` 等），不需要特别的边界检查来防止超出容量。

3. **简化代码和逻辑**：将 `cap` 设置为 `usize::MAX` 还有助于简化和统一处理 ZST 和非 ZST 的代码逻辑。例如，在扩容、插入或删除等操作中，不需要编写特殊的条件代码来处理 ZST 的情况，可以使用统一的处理流程，因为对于 ZST 来说，这些操作不会引起错误或异常情况。

## 2.2 `grow()`

相较于之前`RawVec.grow()`，多了一行：
`assert!(mem::size_of::<T>() != 0, "capacity overflow");`
这个设计意味着，对于 ZST 的 `RawVec`，你不期望它们的容量在运行时发生改变，因为逻辑上你已经允许它们拥有无限容量（`cap` 设置为 `usize::MAX`）。任何尝试改变容量的操作对于 ZST 来说都是多余的，因为它们不占用额外的内存。

## 2.3 `drop()`

相较于之前`RawVec::drop()`，if 语句多了一个条件判断：

```rust
let elem_size = mem::size_of::<T>();
if self.cap != 0 && elem_size != 0 {...}
```

只有当`cap != 0` 且 非 ZST 类型 的数据 才需要`drop`
