在 Rust 中使用 `NonNull<T>` 来实现 `MyVec<T>`（以及类似的标准集合类型）时处理空集合的内存管理策略。

# 1. MyVec::new()

在 Rust 中，创建一个空的 MyVec（例如通过 MyVec::new()）实际上是不会分配任何内存的。这是 Rust 标准库为了优化性能而做的设计选择。当你创建一个新的 MyVec 时，它的容量（cap）为 0，并且它的指针指向一个特殊的值，这个值通常是 NonNull::dangling() 或类似的，以表示指针不指向任何有效的内存。

## 1.1 为什么不分配内存？

在 Rust 标准库的 `Vec<T>` 实现中，一个空的 `Vec`（即长度和容量都为 0 的向量）并不分配任何内存。这是一个优化，目的是减少内存使用和提高性能。特别是当创建许多空的 `Vec` 时，避免内存分配可以显著降低资源消耗和提高应用程序的响应速度。

## 1.2 零大小的内存块和未定义行为

全局分配器通常不允许分配零大小的内存块，因为这可能导致未定义行为。在 Rust 中，要保证所有的内存分配都有非零大小，是因为零大小的分配可能会返回一个无效的指针，而这种情况需要特别处理，否则会导致程序错误。

## 1.3 使用 `NonNull<T>` 和 `NonNull::dangling()`

为了避免在 `MyVec::new()` 中创建一个实际上并未分配内存的 `MyVec` 时使用空指针（`null`），`MyVec` 使用了 `NonNull<T>` 类型的指针。`NonNull<T>` 是一个保证永不为空的智能指针，这意味着它总是指向某个有效的内存地址。

当 `MyVec` 是空的时候（即没有元素且没有分配内存），`MyVec` 的实现使用了 `NonNull::dangling()` 方法来获取一个“悬挂”指针，这个指针实际上是对齐到 `T` 类型的一个虚假地址。悬挂指针是合法的但不指向任何有意义的内存位置。这种做法的好处是，悬挂指针在技术上是有效的（不是 `null`），但又不指向任何真实的分配内存，因此可以安全地用在需要 `NonNull` 的上下文中。

## 1.4 使用“悬挂”指针的合理性

由于在实际的 `MyVec` 操作中，如 `push` 或 `pop` 等，都会检查容量 (`cap`) 是否足够，因此只有当 `cap > 0` 时才会进行实际的内存访问。当 `cap == 0` 时，即使 `ptr` 是一个悬挂指针，也不会有任何内存访问尝试，因此不会导致非法内存访问或其他错误。

总结来说，`MyVec::new()` 中使用 `NonNull::dangling()` 方法是一种内存管理策略，旨在优化空 `MyVec` 的内存使用并保持类型安全性，同时避免未定义行为和非法内存访问。这是 Rust 标准库在设计和实现高效、安全的数据结构时考虑的细节之一。

## 1.5 代码：

```rust
use std::mem;

impl<T> MyVec<T> {
    pub fn new() -> Self {
        assert!(mem::size_of::<T>() != 0, "We're not ready to handle ZSTs");
        MyVec {
            ptr: NonNull::dangling(),
            len: 0,
            cap: 0,
        }
    }
}

```

这段代码是 Rust 中一个简化版本的 `MyVec<T>` 类型的构造函数实现。`MyVec<T>` 是一个泛型动态数组，可以容纳任意类型 `T` 的元素。这个 `new` 方法定义了如何创建一个新的、空的 `MyVec<T>` 实例。让我们逐步解析这段代码：

### 1.5.1 引入内存相关模块

```rust
use std::mem;
```

这行代码引入了 Rust 标准库中的 `mem`（内存）模块，该模块包含了一些用于操作内存和类型的低级函数，如 `size_of`，这在接下来的代码中用于检查类型 `T` 的内存大小。

### 1.5.2 类型检查

```rust
assert!(mem::size_of::<T>() != 0, "We're not ready to handle ZSTs");
```

我在这里使用了断言，是因为零大小的类型需要在我们的代码中进行一些特殊的处理，我想把这个问题暂时延后。如果没有这个断言，我们早期的一些实现会导致一些非常糟糕的事情。

这行代码使用 `assert!` 宏来确保类型 `T` 的内存大小不为零。在 Rust 中，存在零大小类型（ZSTs），例如 `()` 或某些空枚举，它们不占用内存空间。这个断言检查是为了确保 `MyVec` 不被用来存储零大小类型，因为当前的 `MyVec` 实现可能不支持或未优化以处理零大小类型。

- 如果 mem::size_of::<T>() != 0 为 true（即类型 T 的大小不为零），则 assert! 宏不会做任何事情，程序继续执行。
- 如果 mem::size_of::<T>() != 0 为 false（即类型 T 是一个零大小类型），则 assert! 宏将导致程序 panic，显示错误消息 "We're not ready to handle ZSTs"。这表示程序在当前状态下不支持或没有为处理零大小类型进行优化。

### 1.5.3 MyVec 结构体初始化

```rust
MyVec {
    ptr: NonNull::dangling(),
    len: 0,
    cap: 0,
}
```

这部分是 `MyVec<T>` 构造函数的核心，其中包含三个字段：

- `ptr`: 使用 `NonNull::dangling()` 初始化，这为指针提供了一个假的但有效的内存地址（悬挂指针），用于表示这个指针不指向任何有效的内存。这种方法在空 `MyVec` 的实现中常见，因为它避免了空指针，并且在容器为空时不需要实际的内存分配。
- `len`: 初始化为 `0`，表示 `MyVec` 当前没有包含任何元素。
- `cap`: 也初始化为 `0`，表示 `MyVec` 的当前容量为零，即没有预分配的内存空间。

接下来，我们需要弄清楚，当我们确实想要分配内存时，究竟该怎么做。为此，我们使用全局分配函数 alloc、realloc 和 dealloc，这些函数在稳定的 Rust 中可以使用 std::alloc。在 std::alloc::Global 类型稳定后，这些函数将被废弃。

# 2. 内存分配

## 2.1 Rust 中的内存分配

在 Rust 中，大部分内存分配操作通常是自动管理的，比如通过 `Box<T>`, `Vec<T>`, 或其他集合类型。然而，有时候需要更细粒度的控制，尤其是在实现这些集合类型或其他低级数据结构时。此时，你会直接与内存分配器进行交互。

## 2.2 使用 `std::alloc`

`std::alloc` 模块提供了一组用于低级内存管理的 API。这些函数包括：

- **`alloc`**: 分配一定数量的字节的内存。它返回一个指向分配的内存的原始指针。
- **`realloc`**: 改变已分配内存块的大小。这可能涉及将数据移动到一个新的更大或更小的内存块。
- **`dealloc`**: 释放先前通过 `alloc` 或 `realloc` 分配的内存块。

这些函数是用于直接与全局内存分配器交互的基本工具，允许开发者在 Rust 程序中进行显式的内存管理。

## 2.3 稳定性和未来的变化

原文中提到，随着 `std::alloc::Global` 类型的稳定，现有的全局分配函数（`alloc`, `realloc`, `dealloc`）可能将被废弃。`std::alloc::Global` 是一个代表全局分配器的类型，提供了更统一和可能更方便的接口来处理全局内存分配。这表明 Rust 标准库的开发者在努力提供更清晰、更安全的内存管理接口。

这段话讨论了在 Rust 中如何处理内存分配失败（通常称为内存不足，或 OOM——Out of Memory）的情况。这里涉及到的是选择如何优雅地处理程序在尝试分配内存时遇到系统资源不足的情况。下面是对这段话中的几个关键点的详细解释：

# 3. 处理内存不足

## 3.1 处理内存不足的方法

在 Rust 标准库中，当内存分配失败时，可以使用 `alloc::handle_alloc_error` 函数来处理这种情况。这个函数的行为是中止（abort）程序，而不是触发 panic。中止程序意味着立即停止程序运行，不进行任何清理操作，也不会触发 Rust 的 panic 机制中的堆栈展开（unwinding）。

## 3.2 中止而非 Panic

选择中止而不是 panic 的主要原因是，堆栈展开（即 unwinding 过程）本身可能会引发进一步的内存分配。如果内存分配器已经报告内存不足，再进行可能需要额外内存的操作（如堆栈展开）可能会加剧问题，甚至导致程序行为不确定。

## 3.3 内存不足的现实情况

实际上，大多数现代操作系统并不会以传统意义上的“用尽所有可用内存”来表现内存耗尽。操作系统通常通过一些机制（如虚拟内存、交换空间等）来管理可用内存。只有在极端情况下（例如，应用程序一次性请求大量内存，超出了系统的处理能力），操作系统才可能采取措施（如终止一些运行中的程序）来回收内存。

## 3.4 选择与标准库一致的行为

尽管在许多情况下，即使发生内存不足，使用 panic 来处理可能在技术上是可行的（因为现代操作系统的内存管理方式），但为了保持与 Rust 标准库的行为一致，选择中止程序是更稳妥的选择。这样做可以确保在面对内存不足时，程序的行为是可预测和一致的，尽管这意味着程序会突然停止。

## 3.5 动态分配内容的逻辑

```
if cap == 0 :
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
```

这段代码的主要目标是实现 `MyVec` 的动态扩容功能，即在向 `MyVec` 添加元素时，当容量不足时自动增加内存容量，以便容纳更多的元素。下面是这段代码的逻辑解释：

1. **检查当前容量是否为零：**
   如果当前容量（`cap`）为零，意味着 `MyVec` 目前没有分配任何内存。在这种情况下，需要调用 `allocate()` 函数来分配一定数量的内存。通常，初始分配的大小可以是一个较小的值，例如 1 个元素的大小，以节省内存。

2. **分配内存并更新容量：**
   在调用 `allocate()` 函数后，需要将 `cap` 设置为适当的值，以反映实际分配的内存大小。通常情况下，初始分配的大小会设为 1，因此这里将 `cap` 设置为 1。

3. **容量不为零的情况：**
   如果当前容量不为零，意味着 `MyVec` 已经分配了一定数量的内存。在这种情况下，需要调用 `reallocate()` 函数来重新分配更大的内存块。

4. **重新分配内存并更新容量：**
   在调用 `reallocate()` 函数后，需要将 `cap` 更新为新分配的内存块的大小。通常情况下，将 `cap` 乘以 2 是一种常见的做法，这样可以有效地在每次扩容时增加容量，同时尽量减少内存重新分配的次数。

综上所述，这段代码实现了 `MyVec` 的动态扩容逻辑，以确保当向 `MyVec` 添加元素时，始终有足够的内存空间可供使用。

# 4. LLVM GEP inbounds

## 4.1 名词解释

### 4.1.1 LLVM

LLVM 最初是 "Low Level Virtual Machine" 的缩写，但现在 LLVM 已经不单指一个虚拟机了，而是一个庞大的编译器项目，它提供了一套完整的编译器基础设施，用来优化编译时间（即时编译）和程序执行时间（提前编译）。LLVM 本身是一个中间表示(IR)和编译器工具链，支持广泛的编程语言和硬件平台。

### 4.1.2 GEP（GetElementPtr）

GEP，全称 "GetElementPtr"，是 LLVM 指令集中的一种。这是一个用于计算和访问复杂数据结构（如数组、结构体）内元素的地址的指令。GEP 允许开发者指定一个或多个索引，并计算从基础地址开始，通过这些索引偏移后的地址。

### 4.1.3 在原始指针上进行偏移

在许多低级编程语言（如 C/C++ 和 Rust 中的原始指针操作）中，"在原始指针上进行偏移" 是一种常见的操作。这意味着基于一个指向内存中某个位置的指针，计算出另一个位置的指针。在 Rust 中，可以使用 `ptr::offset` 方法来实现这一操作，这需要传入一个整数，表示需要在内存中向前或向后移动多少个元素的距离。

#### 详细举例解释

假设你有一个指向数组开始的指针，并希望访问数组中的第五个元素，你可能会对基地址进行偏移，即向前移动四个元素的位置（数组索引通常从零开始）。在 C/C++ 中，这可能看起来像是 `base_ptr + 4`，而在 Rust 中，如果 `base_ptr` 是一个原始指针，你会使用 `unsafe { base_ptr.offset(4) }` 来获得新的指针。

### 4.1.4 GEP 的 inbounds 语义

当使用 GEP 指令或 Rust 的 `ptr::offset` 时，如果指定 inbounds，这表明所有的偏移操作都保证不会超出被引用的内存对象的边界。这是一种安全和优化的保证：它告诉编译器这些偏移是有效的，不会引起内存越界，编译器因此可以进行更多的优化操作，例如更好地推理出数据依赖性和别名情况，从而生成更有效率的机器代码。

### 4.1.5 别名分析

别名分析是编译器优化中的一个重要方面。编译器需要知道哪些指针可能指向内存中的相同位置，因为这会影响到变量的加载和存储的优化。如果编译器不能确定两个指针是否指向不同的内存位置，它必须保守地处理这些指针的操作，可能会导致一些优化机会的丧失。

### 4.1.6 优化和实例

考虑到示例中的两个操作

```
*x *= 7;
*y *= 3;
```

如果 x 和 y 指向不同的内存位置，那么这两个操作可以并行执行。但如果 x 和 y 指向相同的内存位置，这两个操作就必须串行执行以避免数据竞争和错误。

## 4.2 LLVM 的 GEP 指令以及 Rust 的 ptr::offset 方法存在的问题

### 4.2.1 关于无符号和有符号整数的问题

首先，我们来聊聊什么是无符号和有符号整数：

- **无符号整数**只能表示正数或零。
- **有符号整数**可以表示正数、负数和零。

在编程时，我们经常用无符号整数来表示数组的索引，因为索引不可能是负的（你不会想要访问数组的“第-1 个”元素）。然而，当我们想对一个指针进行操作，比如向前或向后移动时，有符号整数就派上用场了，因为它允许向后移动（使用负数）。

在 Rust 中使用 `ptr::offset` 方法用于对指针进行偏移。这个方法要求传入一个有符号整数作为偏移量，这是因为有符号整数可以表示正值（向前移动）和负值（向后移动），而无符号整数只能表示正值。然而，在某些情况下，如果我们错误地使用一个大的正值作为偏移量，它可能会被解释为一个负值，导致指针偏移方向出错。

### 4.2.2 内存分配的限制

为了避免这种情况，Rust 的标准库限制了内存分配的大小不能超过 `isize::MAX`（有符号整型的最大值）。这样做的目的是确保即使在极端情况下使用最大索引也不会引发错误。换句话说，即使你的数据结构非常大（接近系统允许的极限），使用 `isize::MAX` 作为索引也不会超过这个极限，因此不会产生负索引。

### 4.2.3 平台特定的内存限制

在现代的 64 位平台上，尽管理论上有更广阔的地址空间，实际可用的寻址空间通常被限制在 48 位左右。这意味着即使理论上可能存在更多的地址空间，实际上系统首先会因为耗尽物理或虚拟内存而无法分配超过 isize::MAX 字节的内存。

对于 32 位系统，特别是那些通过物理地址扩展（PAE）等技术使用更多地址空间的系统，理论上可能能分配超过 isize::MAX 字节的内存。这需要特别注意，以防在这些平台上进行大量内存分配时出现问题。

由于这是一个教程，我们在这里不会特别优化，只是无条件地检查，而不是使用聪明的平台特定的 cfgs。

在 Rust 中，`cfg` 是配置条件的缩写，用于编译时条件编译的功能。这些配置条件允许你根据编译目标、功能、操作系统、依赖库等条件来包含或排除代码块。`cfg` 属性可以使代码根据不同的编译环境有不同的行为，非常适合处理跨平台的兼容性问题。

1. 用途
   平台特定的 `cfgs` （即平台特定的配置条件）特别指的是根据目标平台不同而设置的条件编译指令。这些条件可以基于操作系统（如 Windows、macOS、Linux）、硬件架构（如 x86、ARM）、或者甚至是特定的功能可用性来定义。

2. 例子
   例如，你可能有一些只应该在 Linux 系统上运行的代码，可以使用 `cfg(target_os = "linux")` 来确保只有在目标系统为 Linux 时，这部分代码才会被包含编译：

```rust
#[cfg(target_os = "linux")]
fn linux_specific_function() {
    println!("This function is available only on Linux.");
}
```

如果你的程序需要根据是否在测试模式下编译而有不同行为，可以使用 `cfg(test)`：

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_some_functionality() {
        assert_eq!(2 + 2, 4);
    }
}
```

这段代码中的测试模块只会在进行单元测试时编译。

# 5. 空分配

这段内容讨论了在 Rust 中使用 LLVM 编译器进行内存分配时遇到的一些特殊情况，特别是关于空分配的处理。这里的解释涉及到内存分配的语义、别名分析，以及如何在 Rust 中合理处理这些情况。让我们一步步解析这些概念和情形。

## 5.1 空分配的概念

在编程中，**空分配**指的是分配大小为零的内存块。这种情况主要出现在两种场景中：

1. **任意类型的 `cap = 0`**：即尝试为一个元素容量（capacity）为零的数据结构分配内存。
2. **零大小类型（zero-sized types）的 `cap > 0`**：零大小类型是那些不占用任何存储空间的类型，如空元组 `()`。即使这些类型本身不占用空间，我们仍可能尝试为它们分配内存。

## 5.2 LLVM 对“分配”的理解

LLVM 的内存分配概念较为抽象。它需要兼容多种编程语言的内存管理模型，不能像特定语言那样精确控制内存分配。在 LLVM 中，关于内存分配的核心思想是保证不同类型的内存（如堆、栈和全局变量）不会随机重叠，即它们在内存地址上是互不干扰的。这也与别名分析密切相关，别名分析的目的是优化内存访问，通过分析来确定哪些内存地址可以被认为是不重叠的。

## 5.3 任意类型的 cap = 0

当我们谈论到为任意类型进行的空分配，cap = 0 的情况，意味着尽管这个类型可能占用一定的存储空间，但请求的分配的容量为零。这意味着程序或库请求创建一个空的数据容器，如一个空的向量或数组。

在这种情况下，即使数据类型本身占用内存，分配函数不需要在内存中实际分配空间。例如，一个 Vec<T>（向量）在 Rust 中，如果初始化时容量（cap）被设为零，实际上并不会进行任何内存分配。这种处理避免了不必要的内存使用，也简化了内存管理。即使对这样的向量进行元素添加操作，只有在实际需要存储数据时，内存分配才会被触发，并相应地更新容量。

### 5.3.1 特殊处理的必要性

对于 cap = 0 的情况，Rust 和 LLVM 必须确保即使没有分配实际内存，相关的内存操作仍应该是安全的。这通常通过将数据结构的内部指针设置为一个特定的非空（但不指向有效内存的）地址来实现，如使用 NonNull::dangling() 这样的技巧。这样可以保持类型的非空保证，同时不涉及实际的内存位置。

## 5.4 零大小类型的空分配（Zero-Sized Types）

零大小类型指的是那些在内存中不占用任何空间的类型。在 Rust 中，一个典型的零大小类型是空元组 ()。其他可能的零大小类型包括某些形式的泛型结构，其中没有任何非静态数据。

- 空分配的情况：即使对于零大小类型，程序代码可能仍会尝试创建这些类型的实例，可能还会尝试声明这些实例的容器（如向量）有一个大于零的容量。然而，由于每个实例实际上不占用任何空间，所以实际上并不需要为它们分配内存空间。
- 处理方式：在这种情况下，Rust 的内存分配策略是非常简单的。无论请求多少数量的零大小类型实例，实际上都不进行任何内存分配。即便如此，语义上这些实例是存在的，可以创建和操作，但它们不对应于内存中的任何实际位置。

## 5.5 正值大小类型的空分配（Non-Zero-Sized Types）

正值大小类型指的是那些每个实例在内存中确实占用空间的类型，例如基本数据类型（如 i32, f64）和结构体等。

- 空分配的情况：即使是正值大小的类型，也可能出现其容器（如向量）被初始化但容量设置为零的情况。这意味着在初始化时，没有为这些类型的实例预留任何内存空间。
- 处理方式：对于正值大小类型的容器，如果其初始容量设置为零，则不进行实际的内存分配。这是为了效率和资源节约。如果后续需要添加元素到这样的容器中，那么容器的容量将根据需要进行动态扩展，这时才会进行实际的内存分配。

## 5.6 总结

因此，尽管 Rust 可以在技术上对空分配采取一些灵活的处理，但为了保持一致性和安全性，最终采取了较为保守的假设和处理措施。这意味着在实现和编译时，Rust 会尽量避免在 LLVM 层面引入可能导致错误或未定义行为的情况。

# 6. 代码

```rust
use std::alloc::{self, Layout};

impl<T> MyVec<T> {
    fn grow(&mut self) {
        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::<T>(1).unwrap())
        } else {
            // 因为 self.cap <= isize::MAX，所以不会溢出
            let new_cap = 2 * self.cap;

            // `Layout::array` 会检查申请的空间是否小于等于 usize::MAX，
            // 但是因为 old_layout.size() <= isize::MAX，
            // 所以这里的 unwrap 永远不可能失败
            let new_layout = Layout::array::<T>(new_cap).unwrap();
            (new_cap, new_layout)
        };

        // 保证新申请的内存没有超出 `isize::MAX` 字节的大小
        assert!(new_layout.size() <= isize::MAX as usize, "Allocation too large");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::<T>(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 如果分配失败，`new_ptr` 就会成为空指针，我们需要对应 abort 的操作
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) => p,
            None => alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}
```

这段代码是一个简化版的 `MyVec<T>` 实现中的 `grow` 方法，它负责在容量不足时扩展向量的内存。这是 Rust 中动态数组实现的一个关键部分，涉及到内存管理和安全的内存操作。

## 6.1 引入必要的模块

```rust
use std::alloc::{self, Layout};
```

这行代码引入了 Rust 标准库中的 `alloc` 模块和 `Layout` 类型。`alloc` 模块提供了底层的内存分配、重新分配和释放函数。`Layout` 类型则用于描述内存布局，这在请求内存分配时非常重要。
其中，`self`关键之指代`alloc`模块本身。允许代码中直接使用 `alloc` 代替 `std::alloc`。

内存布局（Memory Layout）是一个描述数据在内存中如何被组织和存储的概念。更具体地说，内存布局涉及到数据结构的大小、对齐方式、以及这些结构在内存中的排列顺序。这对于理解程序如何高效地访问和管理内存至关重要:

1. 大小（Size）
   大小是一个对象所占用的内存字节数。对于基本数据类型如 int 或 float，大小通常是固定的（如在大多数系统上 int 是 4 字节）。对于复杂数据类型（如结构体或数组），大小取决于其所有成员的大小总和（考虑到任何内部填充）。
2. 对齐（Alignment）
   对齐是指对象在内存中的起始地址必须是其某个特定字节数（对齐值）的倍数。对齐是由对象中最大的基本数据类型的对齐需求决定的。这是为了硬件访问内存的效率。许多硬件平台都有对齐要求，不遵守这些要求可能会导致性能下降或运行时错误。
3. 排列顺序（Ordering）
   在复合数据结构中（如结构体或类），各个成员的排列顺序也是内存布局的一部分。语言和编译器通常保证在声明中先出现的字段在内存中也出现在先前的位置（尽管可能会有填充来满足对齐要求）。

## 6.2 grow 方法实现

```rust
impl<T> MyVec<T> {
    fn grow(&mut self) {
```

这部分代码定义了 `MyVec<T>` 结构体的 `grow` 方法。`&mut self` 表示这个方法需要一个对 `MyVec<T>` 的可变引用，因为我们可能会改变它的内部状态（如内部的指针和容量）。

## 6.3 计算新的容量和内存布局

```rust
let (new_cap, new_layout) = if self.cap == 0 {
    (1, Layout::array::<T>(1).unwrap())
} else {
    let new_cap = 2 * self.cap;
    let new_layout = Layout::array::<T>(new_cap).unwrap();
    (new_cap, new_layout)
};
```

这里，`new_cap` 和 `new_layout` 是两个局部变量：

- `new_cap` 用于存储向量新的容量。`new_cap=10`或者`Vec::with_capacity(10)`，都是指 vec 中包含的元素数量是 10 个。
- `new_layout` 用于描述这个新容量对应的内存布局。

接下来的条件判断检查当前向量的容量 (`self.cap`) 是否为 0，这是一个常见的检查，因为空向量（容量为 0）需要特殊处理来初始化其存储。

### 6.3.1 cap == 0

- **当 `cap` 为 0 时**，意味着向量目前没有分配任何内存。在这种情况下：
  - 新容量 (`new_cap`) 被设为 1。
  - 使用 `Layout::array::<T>(1)` 创建一个足以存储一个类型 `T` 的元素的内存布局。这里的 `Layout::array` 是一个创建特定数量类型 `T` 元素的数组内存布局的函数。

`Layout::array::<T>(1).unwrap()`

- `Layout::array::<T>(count)` 创建一个数组的内存布局，其中数组的元素类型为 `T`，元素数量为 `count`。这是用来告诉内存分配函数需要多少空间来存储这些元素。
- `.unwrap()` 是一个 Rust 中的方法，用于处理 `Result` 或 `Option` 类型。`Layout::array` 返回 `Result` 类型，因为如果请求的内存大小超过了允许的最大值（`usize::MAX`），就会失败。这里使用 `.unwrap()` 表示程序员断言调用不会失败，如果失败则会导致程序崩溃。

### 6.3.2 非零容量的处理

```rust
let new_cap = 2 * self.cap;
let new_layout = Layout::array::<T>(new_cap).unwrap();
(new_cap, new_layout)
```

- 如果 `self.cap` 不为零，那么新的容量将是当前容量的两倍。这是一种常见的数组扩展策略，称为**指数增长**，可以减少内存重新分配的次数，从而提高性能。
- 同样使用 `Layout::array` 来计算新容量所需的内存布局，并使用 `unwrap()` 确认操作的有效性。由于 `self.cap` 保证小于或等于 `isize::MAX`，新容量最多为 `2 * isize::MAX`，这应该仍然小于 `usize::MAX`，因此不会导致溢出。

`Layout::array`源码：https://rustwiki.org/zh-CN/src/core/alloc/layout.rs.html#431

- self.cap 的约束：
  在 Rust 和其他使用索引的编程语言中，索引的最大可能值通常受限于 isize::MAX。这是因为索引可能需要支持负数（尽管在很多情况下不会这样使用），而 isize 是有符号整数类型，其正数范围限定为 isize::MAX。
  在数组或向量的上下文中，self.cap（容量）通常指的是可以在数组或向量中存储的元素的最大数量，这是一个非负数。虽然理论上 usize 更适合表示这类值，但考虑到索引的可能使用场景，通常确保它不会超过 isize::MAX，从而保证在所有操作中都不会产生负数索引或溢出。
- array_size 的计算：
  array_size 是通过 element_size \* self.cap 计算得出的，表示整个数组占用的总字节数。element_size 是单个元素的字节大小。
  这里的关键是确保计算出的 array_size 不超过 usize::MAX，这是因为内存大小必须能被一个 usize 类型的值完整表示（usize 是无符号的，表示范围是从 0 到 usize::MAX）。如果 array_size 超过了 usize::MAX，那么可能发生溢出，导致错误的内存分配尺寸计算。

确保 self.cap 小于或等于 isize::MAX 是为了防止索引溢出。
确保 array_size 不超过 usize::MAX 是为了避免在内存分配时发生字节大小的溢出。

## 6.4 再次检查

```rust
assert!(new_layout.size() <= isize::MAX as usize, "Allocation too large");
```

- 这行 `assert!` 宏用于在运行时验证新的内存布局的大小（`new_layout.size()`）是否超过了 `isize::MAX`。这里，`isize::MAX` 被转换为 `usize` 类型，这是因为`Layout::size()` 返回的是 `usize` 类型的值。
  如果 `new_layout.size()` 超过了 `isize::MAX`，程序将触发 panic，输出 "Allocation too large"。

在之前提到的代码段中，`Layout::array::<T>(new_cap)` 的确主要检查的是由于乘以元素大小后的内存需求是否超过了 `usize::MAX`。这个检查确保了从理论上分配的内存量不会超出 `usize` 类型可以表示的最大值，从而避免整数溢出和其它相关的内存错误。

### 为什么要再次缩减到`isize::MAX`

在内存分配中：

1. **检查`usize::MAX`**：

   - 当你使用 `Layout::array::<T>(new_cap).unwrap()` 时，你正在请求一个内存布局，它的总大小是元素大小乘以元素数量（`new_cap`）。这里需要确保结果不超过 `usize::MAX`，因为 `usize` 是用来描述大小和索引的，并且是操作系统和硬件平台用来管理内存的基本类型。
   - 这种检查是为了防止请求过大的内存分配导致的溢出错误，特别是在内存大小计算时（例如，元素大小乘以数量可能超过 `usize` 能表示的范围）。

2. **检查`isize::MAX`**：
   - 另一方面，检查 `new_layout.size() <= isize::MAX as usize` 是基于安全考虑，防止某些特定平台或系统函数因为内部使用 `isize` 来处理大小而导致问题。这种情况虽不常见，但在一些旧的或特定的系统中，内存分配函数可能会使用有符号整数来表示内存大小。
   - 这是一种额外的安全措施，确保在所有情况下，分配的内存大小都不会超过系统或库函数能够安全处理的最大值。

`Layout::array::<T>(new_cap).unwrap()` 主要确保不超过 `usize::MAX`，这主要是防止溢出。而 `isize::MAX` 的检查更多的是一种保守的做法，用于确保在所有平台上分配的内存都在安全的处理范围之内，特别是对于那些可能还在使用有符号整数进行内存管理的系统或库。这两种检查虽然看起来有些重复，但实际上是为了确保在不同的系统和环境中都能安全运行。

## 6.5 内存分配

```rust
let new_ptr = if self.cap == 0 {
    unsafe { alloc::alloc(new_layout) }
} else {
    let old_layout = Layout::array::<T>(self.cap).unwrap();
    let old_ptr = self.ptr.as_ptr() as *mut u8;
    unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
};
```

这里，根据是否是首次分配来决定使用 `alloc` 还是 `realloc`。`alloc::alloc` 用于新分配内存。
而 `alloc::realloc` 用于重新分配内存，以适应更大的容量需求。`alloc::realloc` 函数将根据旧内存块的地址 `old_ptr` 和布局 `old_layout`，以及新的布局 `new_layout.size()` 来重新分配内存。这可能会在原地扩展现有内存块的大小，或者在另一个位置分配一个新的更大的内存块，并将旧数据复制到新的内存块中。realloc 的行为取决于系统和内存分配器的实现。

`alloc` 和 `realloc` 函数在处理完成后都会返回一个指针(`*mut u8`)，这些指针指向分配或重新分配的内存块。但它们不提供自动的错误处理机制，需要程序员自行确保使用安全。例如，在 MyVec 的实现中，如果 `alloc` 或 `realloc` 返回一个空指针，通常会调用 `alloc::handle_alloc_error` 来处理这种情况，这个函数会根据配置决定是触发 panic 还是执行其他错误处理逻辑。

注意，这些操作被标记为 `unsafe`，因为不正确的使用可能导致内存安全问题。

## 6.6 处理分配失败

```rust
self.ptr = match NonNull::new(new_ptr as *mut T) {
    Some(p) => p,
    None => alloc::handle_alloc_error(new_layout),
};
```

`NonNull::new(new_ptr as *mut T)`
这行代码尝试创建一个 `NonNull<T>` 类型的实例，其中 `new_ptr` 是一个指向 `T` 类型数据的原始指针。我们来逐步解释这行代码的各个部分：

- `new_ptr as *mut T`：这部分是一个类型转换操作，将 `new_ptr`（通常是一个 `*mut u8` 类型的指针，因为它来自于 `alloc` 或 `realloc` 函数）转换为 `*mut T` 类型。这个转换是必需的，因为 `new_ptr` 指向的是分配的内存块，而这块内存是要被用来存放类型 `T` 的数据的。
- `NonNull::new(...)`: 这个函数尝试根据提供的原始指针创建一个 `NonNull<T>` 实例。它的参数是一个 `*mut T` 类型的原始指针。`NonNull::new` 函数会检查这个指针是否非空：
  - 如果指针是非空的，`NonNull::new` 会成功返回 `Some(NonNull<T>)`，包装了这个非空指针。
  - 如果指针是空的，即 `null`，那么 `NonNull::new` 会返回 `None`，表示没有创建有效的 `NonNull<T>` 实例。随后调用 `alloc::handle_alloc_error` 来处理分配错误（通常是通过终止程序）。

## 6.7 更新 MyVec 的状态

```rust
self.cap = new_cap;
```

最后，更新 `MyVec` 的容量属性为新的容量。
