# 1. MyIntoIter

> `deref`已经将 iter 和 iter_mut 已经为我们写好了。然而，有两个有趣的迭代器是 `Vec` 提供的，而 `slice` 不能提供：`into_iter`和`drain`。

## 1.1 `MyIntoIter` 迭代器

`MyIntoIter`通过消耗`Vec`的值（即获取`Vec`的所有权），来生成其元素的值。这意味着`MyIntoIter`迭代器拥有`Vec`的所有权，并能够安全地将`Vec`中的元素逐一转移给调用者。

### 1.1.1 控制分配

因为`MyIntoIter`会消耗`Vec`，所以它需要掌控`Vec`的内存分配。这一点非常重要，因为当迭代器被销毁时，它需要正确地释放`Vec`所占用的内存，以防止内存泄漏。

## 1.2 `DoubleEndedIterator`

`MyIntoIter`不仅是一个简单的迭代器，它还是一个双端迭代器（`DoubleEndedIterator`），这意味着它可以从`Vec`的两端进行迭代：既可以从头部开始，也可以从尾部开始。

### 1.2.1 从尾部读取

从尾部读取元素很简单，可以使用`pop`方法。`pop`方法从`Vec`的尾部移除一个元素并返回该元素，这种操作是常数时间复杂度的。

### 1.2.2 从头部读取

从头部读取则稍显复杂。虽然可以使用`remove(0)`方法，但这种方法会导致所有后续元素的移动，效率很低。为了高效地从头部读取，我们可以使用`ptr::read`函数。`ptr::read`函数允许我们从指定的内存地址读取数据，而不会影响内存中的其他数据。

## 1.3 使用指针迭代

为了高效地实现双端迭代，我们使用两个指针：

- 一个指针指向数组的起始位置（`start`）。
- 另一个指针指向数组结束后的一个元素（`end`）。

当我们从一端读取元素时，我们移动相应的指针，并通过`ptr::read`读取指向的值。当这两个指针相遇时，表示所有元素都已迭代完毕。

## 1.4 `next` 和 `next_back` 的差异

在实现迭代器时，`next` 和 `next_back` 这两个方法用于从不同方向读取元素。具体来说：

- `next` 用于从头部开始读取元素。
- `next_back` 用于从尾部开始读取元素。

### 1.4.1 指针的位置

- 对于`next`方法，指针正好指向它要读取的当前元素。
- 对于`next_back`方法，指针总是指向它要读取的元素的后一个位置。

### 1.4,2 为什么会有这样的设计

为了理解为什么要这样设计，我们可以考虑一个特殊的情况：假设我们已经读取了数组中的所有元素，只剩下最后一个元素尚未读取。此时指针的位置会有如下差异：

#### 1.4.2.1 示例数组

假设我们的数组是这样的：

```
[X, X, X, O, X, X, X]
```

其中 `X` 表示已经读取的元素，`O` 表示下一个将要读取的元素。

在这种情况下：

- 对于`next`方法，Start 指针正好指向最后一个`O`元素。
- 对于`next_back`方法，End 指针位于`O`元素之后。

具体位置如下：

```
          S  E
[X, X, X, O, X, X, X]
```

#### 1.4.2.2 如果 `E` 直接指向下一个元素

如果`E`（即`next_back`的方法指针）直接指向下一个将要读取的元素，它将无法区分是否还有元素可以读取。例如，当所有元素都已经读取完毕时，指针位置如下：

```
          E
          S
[X, X, X, X, X, X, X]
```

此时`E`指向的位置与仍有元素可以读取的情况相同，

```
          E
          S
[X, X, X, O, X, X, X]
```

无法区分到底是否已经读取完所有元素。

#### 设计上的考虑

为了避免这种混淆，`next_back`方法的指针总是指向要读取元素的后一个位置。当指针`E`和`S`相等时，即可明确表示已经没有元素可供读取了。这种设计确保了我们能够正确地判断迭代是否结束。

### 实现中的具体操作

#### `next` 方法

- 指针`S`初始指向第一个元素。
- 每次调用`next`方法时，读取指针`S`指向的元素，然后将指针`S`向后移动一个位置。

#### `next_back` 方法

- 指针`E`初始指向数组结束后的一个位置。
- 每次调用`next_back`方法时，先将指针`E`向前移动一个位置，然后读取指针`E`指向的元素。

这种设计的主要目的是为了明确区分迭代过程中是否还有元素可供读取。通过让`next`和`next_back`方法的指针在读取和移动上的顺序有所不同，可以避免指针位置混淆，确保迭代器在不同方向迭代时都能正确地判断结束条件。

虽然 `end` 指针指向的位置实际上超出了数组的物理边界，但这种行为通常不被认为是越界：尽管 `end` 指针指向数组的边界之外，它本身并不用于访问任何数据。`end` 仅作为一个界标使用，来确定何时停止迭代。这意味着，只要没有试图解引用 `end` 指针所指向的位置，就不会违反 Rust 的安全规则。

## 1.5 保留分配信息

在迭代过程中，虽然我们不直接处理`Vec`的分配信息，但我们需要保留这些信息，以便在`MyIntoIter`被丢弃后能够正确释放内存。这确保了`MyIntoIter`不仅能正确地提供元素，还能妥善地管理内存资源。

## 1.6 注意事项

在 Rust 中，`MyIntoIterator` 和 `MyIntoIter` 是两个不同的概念，分别用于描述迭代器的特性和具体的迭代器实现。这两者经常一起使用，但它们的角色和功能有明显的区别：

### 1.6.1 MyIntoIterator 特质

- **特性（Trait）**：`MyIntoIterator` 是一个 Rust 的标准库中的特性（trait），它被用来定义那些可以被转换成迭代器的类型。任何实现了 `MyIntoIterator` 特性的类型都可以通过某种方式转换成迭代器，允许它被用在例如 `for` 循环中。
- **通用性**：`MyIntoIterator` 特性定义了一个方法 `into_iter`，这个方法消费（takes ownership of）原始结构，返回一个用于遍历该结构的迭代器。这意味着 `MyIntoIterator` 特性可以被实现在各种类型上，如数组、集合或任何自定义集合类型。
- **方法签名**：
  ```rust
  trait MyIntoIterator {
    type Item;
    type MyIntoIter: Iterator<Item = Self::Item>;
    fn into_iter(self) -> Self::MyIntoIter;
  }
  ```
  这个签名表明任何实现 `MyIntoIterator` 的类型都必须指定它生成的迭代器类型 `MyIntoIter` 以及迭代器返回的元素类型 `Item`。

### 1.6.2 MyIntoIter 结构体

- **具体的迭代器类型**：`MyIntoIter` 通常是一个具体的结构体或类型，用于实现迭代器接口。在很多 Rust 的集合类型（如 `Vec`, `HashMap` 等）中，你会发现一个名为 `MyIntoIter` 的结构，这个结构体是这些集合类型为了支持迭代而具体实现的迭代器。
- **功能**：`MyIntoIter` 结构体通常持有原始数据的所有权，并在迭代过程中逐项返回数据。它实现了 `Iterator` 特性，定义了如何逐一访问集合中的每个元素。
- **示例实现**：

  ```rust
  struct MyIntoIter<T> {
    // 实现细节
  }

  impl<T> Iterator for MyIntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
      // 迭代逻辑
    }
  }
  ```

### 1.6.3 特质和结构体是如何协作的：

#### 1.6.3.1 MyVec 结构体 和 MyIntoIterator 特质

- **`Vec<T>`** 实现了 `MyIntoIterator` 特性。这意味着 `Vec<T>` 可以转换成一个迭代器，这个迭代器能够遍历 `Vec` 中的元素。实现 `MyIntoIterator` 的目的是允许 `Vec<T>` 直接用在 `for` 循环等迭代上下文中。

#### 1.6.3.2 MyIntoIter 结构体

- **`MyIntoIter<T>`** 是一个具体的结构体，通常作为 `Vec<T>` 实现 `MyIntoIterator` 时返回的迭代器类型。`MyIntoIter<T>` 不需要实现 `MyIntoIterator` 特性，因为它本身就是迭代器，而不是可以被转换成迭代器的类型。相反，它直接实现了如下几个特性：
  - **`Iterator`**：这是所有迭代器都必须实现的基础特性，提供了 `next` 方法用于遍历元素。
  - **`DoubleEndedIterator`**：这是一个可选特性，为可以从两端同时进行迭代的迭代器提供额外的 `next_back` 方法。`MyIntoIter<T>` 实现此特性允许从 `Vec` 的末尾向前迭代，这对于某些算法和操作是非常有用的。
  - **`Drop`**：当 `MyIntoIter<T>` 被销毁时，需要正确地释放或处理它所拥有的资源。因为 `MyIntoIter<T>` 持有原始 `Vec<T>` 的元素，它需要确保在迭代器生命周期结束时正确地处理这些元素和相关资源。

#### 1.6.3.3 总结

- **`MyIntoIterator`** 适用于那些可以转换成迭代器的类型，例如 `Vec<T>`。
- **`MyIntoIter<T>`** 是转换过程中实际使用的迭代器类型，它不需要再实现 `MyIntoIterator`，因为它本身就是一个迭代器。
- **`Iterator` 和 `DoubleEndedIterator`** 都是定义迭代行为的特性，`MyIntoIter<T>` 必须实现这些以提供迭代功能。

## 1.7 代码

### 1.7.1 结构体 `MyIntoIter<T>`

```rust
pub struct MyIntoIter<T> {
    buf: NonNull<T>,
    cap: usize,
    start: *const T,
    end: *const T,
}
```

这个结构体 `MyIntoIter<T>` 表示 `MyVec<T>` 的迭代器。它包含了以下字段：

- `buf`：一个指向 `MyVec<T>` 分配内存的指针，使用 `NonNull<T>` 类型，确保不为空。
- `cap`：分配的内存空间大小。
- `start`：一个指向迭代器开始位置的指针，即第一个元素的地址。
- `end`：一个指向迭代器结束位置的指针，即最后一个元素之后的地址。

### 1.7.2 `IntoIterator` 实现

```rust
impl<T> IntoIterator for MyVec<T> {
    type Item = T;
    type MyIntoIter = MyIntoIter<T>;

    fn into_iter(self) -> MyIntoIter<T> {
        // 确保 MyVec 不会被 drop，因为那样会释放内存
        let vec = ManuallyDrop::new(self);

        // 获取 Vec 的指针、容量和长度
        let ptr = vec.ptr;
        let cap = vec.cap;
        let len = vec.len;

        // 创建 MyIntoIter 实例并返回
        MyIntoIter {
            buf: ptr,
            cap,
            start: ptr.as_ptr(),
            end: if cap == 0 {
                ptr.as_ptr() // 没有分配内存时，start 和 end 指针相同
            } else {
                unsafe { ptr.as_ptr().add(len) } // 分配了内存时，end 指向最后一个元素之后的位置
            },
        }
    }
}
```

在 `IntoIterator` 特性的实现中：

- `type Item = T;`：定义了迭代器产生的元素类型为 `T`。
- `type MyIntoIter = MyIntoIter<T>;`：指定了 `MyVec<T>` 的迭代器类型为 `MyIntoIter<T>`。
- `fn into_iter(self) -> MyIntoIter<T>`：实现了 `into_iter` 方法，接受 `self`（`MyVec<T>`）并返回一个 `MyIntoIter<T>` 类型的迭代器。
  - 首先，使用 `ManuallyDrop` 来确保 `MyVec` 不会在方法中被销毁，因为这将导致内存被释放。
  - 然后，获取 `MyVec` 的指针、容量和长度。
  - 最后，根据 `MyVec` 是否分配了内存，初始化 `MyIntoIter` 结构体，并返回实例。

#### 1.7.2.1 使用`ManuallyDrop`的原因

在 Rust 中，当你使用 `into_iter()` 将 `MyVec<T>` 转换为其迭代器 `MyIntoIter<T>` 时，发生了几件重要的事情：

1. **所有权转移**：`MyVec<T>` 的内存所有权被转移到 `MyIntoIter<T>`。这意味着原来由 `MyVec<T>` 管理的内存现在由 `MyIntoIter<T>` 来管理。`MyVec<T>` 自身的实例已经不再持有这些内存，所以原来的 `MyVec<T>` 对象不能再被用来访问这些数据。

2. **内存延迟释放**：尽管 `MyVec<T>` 的所有权被转移了，但 `MyVec<T>` 的内存并不是立即被释放。这是因为 `MyIntoIter<T>` 需要使用相同的内存来迭代数据。如果 `MyVec<T>` 的内存在转换成 `MyIntoIter<T>` 后立即释放，`MyIntoIter<T>` 就无法正常工作，因为它依赖于那些内存来提供迭代的数据。

3. **使用 `ManuallyDrop`**：为了确保 `MyVec<T>` 在转换为 `MyIntoIter<T>` 时不自动释放内存，使用了 `ManuallyDrop<T>` 包装器。这防止了 `MyVec<T>` 的自动析构行为，即自动调用其析构函数以释放内存。`ManuallyDrop<T>` 允许我们手动控制何时释放内存。

4. **迭代器的责任**：一旦 `MyVec<T>` 转换成 `MyIntoIter<T>`，对内存的管理责任完全转移到了 `MyIntoIter<T>`。`MyIntoIter<T>` 需要确保在其生命周期结束时，正确地处理剩余的元素（如果有需要的话，调用它们的析构函数）并释放内存。这通常在 `MyIntoIter<T>` 的 `Drop` 实现中完成。

### 1.7.3 向前迭代：实现`Iterator` 特质

```rust
impl<T> Iterator for MyIntoIter<T> {
    type Item = T;
    ...
}
```

- `type Item = T;`：这行定义了迭代器返回元素的类型为 `T`。

#### 1.7.3.1 实现方法 next()

```rust
    fn next(&mut self) -> Option<T> {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }
```

- `if self.start == self.end`：这个条件检查是否已经迭代到了内存区域的末尾（即开始指针等于结束指针）。如果是，返回 `None` 表示迭代结束。
- `unsafe { ... }`：`unsafe` 块用于执行可能不安全的操作，这里指的是直接从内存中读取值。这是必要的，因为 Rust 默认不允许直接进行可能导致未定义行为的内存操作。
- `let result = ptr::read(self.start);`：使用 `ptr::read` 从迭代器当前的 `start` 指针位置读取一个类型为 `T` 的值。这个函数适用于从原始指针读取值，同时假设该位置的数据是有效的并且适当初始化的。
- `self.start = self.start.offset(1);`：将 `start` 指针向前移动一个元素的位置，为下次调用 `next()` 方法做准备。
- `Some(result)`：返回包含读取到的值的 `Some`，如果还没有迭代到结束的话。

##### 1.7.3.1.1 `add()`和`offset()`的区别

- `add` 方法用于向指针增加一个给定的元素数（而非字节数）。当你使用 `self.start.add(1)` 时，意味着你将指针移动了一个元素的距离。这与元素的类型 `T` 的大小有关，是按类型的大小计算的。如果 `T` 的大小是 8 字节，`add(1)` 就会将指针向前移动 8 字节。

- `offset` 与 `add` 非常相似，因为它也是按元素类型的大小来移动指针。`self.start.offset(1)` 实际上和 `self.start.add(1)` 功能相同，都是将指针向前移动一个类型 `T` 的大小。`offset` 接受一个 `isize` 类型的参数，允许正数或负数，因此可以向前或向后移动。

在常规使用中，`add` 被视为更安全和更符合 Rust 的内存安全原则，因为它不允许使用负索引，从而减少了错误的风险。而在代码示例中，使用 `add` 或 `offset` 实际上是等价的，因为你只需要向前移动指针。

#### 1.7.3.2 实现方法 size_hint()

```rust
    fn size_hint(&self) -> (usize, Option<usize>) {
        let len = (self.end as usize - self.start as usize)
                  / mem::size_of::<T>();
        (len, Some(len))
    }
```

- `fn size_hint(&self) -> (usize, Option<usize>)`：这个方法提供了迭代器还剩多少元素的估计，这对优化某些迭代操作很有帮助。
- 计算 `len`：通过将 `end` 指针和 `start` 指针的地址相减，得到两者之间的字节差，然后除以每个元素的大小（`mem::size_of::<T>()`），得到剩余元素的数量。
- `(len, Some(len))`：返回一个元组，第一个元素是剩余最少元素的数量，第二个元素是剩余最多元素的数量。在这种情况下，因为 `start` 和 `end` 是确切的边界，所以这两个值是相同的。

这个实现非常典型地展示了如何安全地处理原始指针以及如何在 Rust 中实现迭代器来遍历某个内存区块的元素。

#### 1.7.3.3 关于 `size_hint()`

`size_hint()` 是 Rust 中 `Iterator` trait 的一个方法，用于提供迭代器剩余元素数量的估计范围。这个方法返回一个元组 `(usize, Option<usize>)`，其中：

1. **第一个元素**（下界）：表示迭代器至少还能提供多少个元素。这是一个确定的数值，表示迭代器最小的剩余长度。
2. **第二个元素**（上界）：一个 `Option<usize>`，表示迭代器最多还能提供多少个元素。如果是 `Some(usize)`，则说明迭代器能提供的最大元素数量；如果是 `None`，则表示上界未知或无法确定。

主要用途：

- **优化**：`size_hint()` 主要用于性能优化，例如在迭代之前预留足够的容器空间，减少运行时的内存分配和复制操作。
- **非强制性**：尽管 `size_hint()` 提供了元素数量的估计，但它不强制迭代器必须严格遵循这一估计。迭代器的实现可能由于错误或设计上的考虑，提供少于下界或多于上界的元素。

注意事项：

- **安全性**：即使 `size_hint()` 实现不准确，也不应导致内存安全问题。它不应被用于安全相关的逻辑，如省略数组访问的边界检查。
- **协议的遵守**：虽然不强制，但迭代器应尽可能提供准确的 `size_hint()`，以符合 `Iterator` trait 的设计意图和规范。

默认实现：

- `Iterator` trait 提供了一个默认的 `size_hint()` 实现，返回 `(0, None)`，适用于所有迭代器，无论它们如何操作。
