# 1. Drain

## 1.1 Drain 与 into_iter 的区别

1. **`drain` 方法**：

   - **借用**：`drain` 是从 `Vec` 中临时借用一部分元素，这是通过借用（非所有权转移）来实现的。这意味着 `drain` 被调用后，原 `Vec` 仍然存在，但它的内容会被部分移除。
   - **不消耗原 `Vec`**：由于 `drain` 只是借用，它不会消耗（即完全移除所有权并使之无效）原 `Vec`。在 `drain` 操作后，原 `Vec` 的长度会减少，但它的容量（即分配的内存空间）不变。
   - **不修改分配**：`drain` 不会改变 `Vec` 已分配的内存大小，只是移除了指定范围内的元素。这意味着，虽然 `Vec` 的内容变了，其底层的内存空间和容量保持不变。

2. **`into_iter` 方法**：
   - **所有权转移**：`into_iter` 方法通过获取 `Vec` 的所有权来创建一个迭代器。这意味着原 `Vec` 完全失效，因为它的所有权已经转移到了迭代器上。
   - **消耗原 `Vec`**：由于所有权的转移，`into_iter` 方法实质上消耗了原 `Vec`，使之不再有效。

所以，当人们说 `drain` 和 `into_iter` 大体上相似，主要是因为两者都可以用来迭代集合中的元素。然而，关键的区别在于 `drain` 是一种借用操作，保留了原 `Vec` 的结构和分配的内存，而 `into_iter` 是一种所有权转移操作，消耗了原 `Vec` 并使其失效。

## 1.2 `Drain` 结构体

```rust
use std::marker::PhantomData;

struct Drain<'a, T: 'a> {
    // 这里需要限制生命周期, 因此我们使用了 `&'a mut Vec<T>`，
    // 也就是我们语义上包含的内容，
    // 我们只会调用 `pop()` 和 `remove(0)` 两个方法
    my_vec: PhantomData<&'a mut MyVec<T>>,
    start: *const T,
    end: *const T,
}

```

生命周期：这里的`'a`表示`Drain`结构体包含的数据将引用一个生命周期为`'a`的`Vec<T>`。这是为了确保`Drain`中的数据在`MyVec<T>`有效期内使用，防止悬挂指针。
`PhantomData`：用于表明`Drain`结构体逻辑上包含一个对`MyVec<T>`的可变引用，虽然实际上它不直接持有`MyVec<T>`。这主要用于帮助 Rust 编译器正确处理生命周期和借用检查。
裸指针：`start`和`end`是裸指针，指向`MyVec<T>`中的元素，用于在迭代中定位当前和结束位置。

### 1.2.1 为什么不直接引用 而使用`PhantomData`

在`Drain`结构体的设计中，如果直接使用`my_vec: &'a mut MyVec<T>`，这意味着`Drain`实际持有了对`MyVec<T>`的可变引用。这样的设计有几个潜在的问题或限制：

1. **所有权与管理**：当`Drain`持有一个实际的`&'a mut MyVec<T>`引用时，`MyVec`的所有权（或更准确地说，修改权）在`Drain`存在期间被部分转移给了`Drain`。这意味着在`Drain`存在的期间内，不能再从外部对`MyVec`进行任何修改，因为 Rust 的借用规则禁止有两个活跃的可变引用指向同一个资源。

2. **灵活性减少**：持有实际引用可能限制了对原始数据结构（如`MyVec`）的某些低级操作，因为 Rust 的安全保障会阻止直接操作可能导致数据不一致的内部结构。例如，使用指针可以在内部更灵活地操作数据，而不受 Rust 安全借用检查的限制（当然，这需要 unsafe 代码块）。

3. **借用的复杂性**：如果`Drain`直接持有`&'a mut MyVec<T>`，它的使用就需要在创建时就必须绑定到一个具体的`MyVec`实例上，这在某些使用场景中可能不太方便。

而使用`PhantomData<&'a mut Vec<T>>`：

- **类型安全**：`PhantomData`允许你在不实际持有数据的情况下，声明对数据的某种“逻辑”依赖或影响。这有助于在不违反 Rust 的所有权和借用规则的前提下，灵活地表示生命周期和借用依赖。
- **避免数据所有权或借用问题**：`PhantomData`使得`Drain`不必实际持有对`MyVec<T>`的引用，而是通过裸指针来处理元素。这样可以在需要时绕过 Rust 的严格借用检查，同时通过`unsafe`代码块明确标明对安全性的手动管理。

总的来说，`PhantomData`提供了一种方式，让开发者能够在类型系统中表达复杂的依赖关系，而不必改变实际的内存布局和所有权模型。这对于实现如`Drain`这类高效且安全的抽象特别有用。

当然，让我们用一个具体的例子来说明 `PhantomData` 的作用和限制，以及在实际的 `Vec<T>` 使用中它如何表达借用规则，但不实施编译时的借用检查。

假设我们有一个简单的 `Drain` 结构体实现，它使用 `PhantomData` 来表示对 `Vec<T>` 的可变引用：

```rust
use std::marker::PhantomData;

struct Drain<'a, T> {
    vec: PhantomData<&'a mut Vec<T>>,
    start: usize,
    end: usize,
}

impl<'a, T> Drain<'a, T> {
    pub fn new(slice: &'a mut Vec<T>, start: usize, end: usize) -> Self {
        // 安全性假设：调用者保证不会在 Drain 存在期间从外部修改 Vec
        Drain {
            vec: PhantomData,
            start,
            end,
        }
    }
}
```

接下来，看看如何使用这个 `Drain` 结构体：

```rust
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];
    let mut drainer = Drain::new(&mut numbers, 1, 3);

    // 假设我们在这里试图再次借用 numbers
    let first = numbers[0];  // 可能不会引起编译错误
}
```

在上述例子中，尽管我们已经通过 `Drain::new` 向 `Drain` 结构体传递了 `numbers` 的可变引用，但因为 `Drain` 内部只使用 `PhantomData` 而不是实际的引用，以下情况可能发生：

- 编译器不会阻止在 `Drain` 存在期间访问 `numbers`。

- `PhantomData` 在这里表示 `Drain` 结构体在逻辑上与 `Vec<T>` 的可变引用相关联，但不实际执行编译器的借用检查。这意味着开发者需要手动确保在 `Drain` 操作期间不对原始的 `Vec<T>` 进行任何修改，以保持程序的正确性和安全性。

# 2. `IntoIter` 和 `Drain` 相同结构用 `RawValIter` 抽象

```rust
struct RawValIter<T> {
    start: *const T,
    end: *const T,
}

impl<T> RawValIter<T> {
    // 构建 RawValIter 是不安全的，因为它没有关联的生命周期，
    // 将 RawValIter 存储在与它实际分配相同的结构体中是非常有必要的，
    // 但这里是具体的实现细节，不用对外公开
    unsafe fn new(slice: &[T]) -> Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if slice.len() == 0 {
                // 如果 `len = 0`, 说明没有分配内存，需要避免使用 offset，
                // 因为那样会给 LLVM 的 GEP 传递错误的信息
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            }
        }
    }
}
```
